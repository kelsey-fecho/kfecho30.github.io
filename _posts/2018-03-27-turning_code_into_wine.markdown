---
layout: post
title:      "Turning Code into Wine"
date:       2018-03-27 14:47:01 -0400
permalink:  turning_code_into_wine
---


My first portfolio project has arrived! 

![](https://media.giphy.com/media/oGT1ial41PRks/giphy.gif)

For my CLI Gem project, I built a Ruby gem that scrapes TotalWine.com and returns data about many different wines. Then, it allows users to interact with that data through a CLI app. Users can browse all wines, wines from a particular region, certain types of wine, or even in order of ratings. From there, interested users can be brought to TotalWine.com to purchase the wine about which they've just educated themselves.

I have to admit that starting with a blank code file was a little intimidating, but I'm really glad the project was structured that way. Sure, passing code challenges is one thing--someone else tells you exactly what the end result needs to do; all you need to do is build it. But here? I got to **design**.

I designed this gem using an inside out approach rather than outside in. What's the difference? An inside-out approach starts with the more technical aspects of a program--the data models and structure--and built *out* from there. The user interface is one of the last things you create. As you might have guessed, an outside-in approach is the exact opposite, and often uses a good deal of pseudo-code in the beginning to fully flesh out your program.

My first instinct would be that outside in development is always the better approach, because why wouldn't you design for your end user who will be essentially writing your checks? However, upon conducting a little outside research, I've found that these two patterns can cause a bit of debate amongst developers.


**Inside Out Development**
* Traditional/classic approach
* Rapid iterative development
* Something always works!

**Outside In Development**
* Facilitates “big picture” thinking
* Closer aligned with UI design goals
* Aligns with YAGNI principles

The overwhelming opinion is that you'll likely use both patterns frequently and the use-cases for each are highly situational. 



